# Многонишково програмиране

## Предпразнична шопинг мания

В седмиците преди Коледа по супермаркетите настава истинска шопинг мания. Никой обаче не обича да чака по опашки. За щастие, повечето вериги разполагат с много каси, които обслужват паралелно клиентите.

Ще имплементираме система, която разпределя конкурентно клиенти по каси за обслужване в супермаркет. Разгледайте класовете и интерфейсите в папката [src](https://github.com/fmi/java-course/blob/master/08-threads/lab/src).

Клиентите са инстанции на класа `Customer`, който има следния конструктор:

```java
public Customer(CashDesk cashDesk, int serviceTime, double totalPrice)
```

Всеки клиент се характеризира с:

- каса, която ще го обслужи
- време, необходимо да бъде обслужен
- сума, за която ще пазарува (т.е. парите, които ще похарчи)

Интерфейсът `CashDesk` има следните методи:

```java
public interface CashDesk {

    /**
     * Serves a customer
     */
    void serveCustomer(Customer customer);

    /**
     * Returns the cash amount currently contained in this cash desk
     */
    double getAmount();

    /**
     * Updates the cash amount currently contained in this cash desk
     */
    void setAmount(double amount);

}
```

### Задача 1

Реализирайте класа `CashDeskImpl`, имплементиращ интерфейса `CashDesk`. Той трябва да представлява единична каса, която поддържа описаните по-горе операции.

Допишете класа `Customer`. Клиентите трябва да могат да бъдат обслужвани асинхронно. Методът `buyGoods()` симулира покупка на каса, като покупката отнема определено време.

```java
    /**
     * Simulates one purchase: waits a bit and returns the amount of money spent
     * (i.e. the goods price)
     */
    public double buyGoods();
```

### Задача 2

Създайте една каса и пуснете конкуретно n на брой клиенти, които да пазаруват от нея. За да не се забави прекалено много изпълнението, може да пуснете 100-500 клиента. На всеки от тях задайте произволно време за обслужване в интервала 0-100 ms.

В main нишката изчакайте всички клиенти да приключат изпълнението си и подсигурете, че балансът на сметката е коректен (т.е. наличната сума в касата след обслужване на всички клиенти е равна на сумата от покупките на всеки от клиент).

### Задача 3

Държането на много пари в наличност в дадена каса не е желателно. Предоставете имплементация на класа `Vault` (трезор), който ще се грижи за прехвърляне на паричния баланс от дадена каса към своя баланс, когато получи сигнал. Инициализирайте и стартирайте нишката. След като последният клиент бъде обслужен, нишката на трезора трябва автоматично да прекрати изпълнението си.

Касата от своя страна трябва да уведоми трезора, когато наличността ѝ е надхвърлила даден лимит, определен от `CashDeskImpl.MAX_CASH`.

Подсигурете, че общият баланс (наличността в касата плюс наличността в трезора) е равeн на сумата от похарчените от клиентите пари.

### Задача 4

Знаем, че нишките са скъпи за създаване ресурси. Делегирайте изпълнението на клиентите на `ExecutorService` с фиксиран размер от 100 нишки. Подсигурете, че главната нишка ще изчака всички клиенти, за да изпише коректния резултат по сметката накрая.

### Задача 5

Обслужването на голям брой клиенти от една каса е крайно неефективно. В големите вериги разбира се има по няколко каси. Ще симулираме подобно поведения чрез класа `Supermarket`, който също имплементира интерфейса `CashDesk`. Супермаркетът ще има няколко каси, съхранявани в подходяща структура. Имплементирайте метода `serveCustomer()` Всеки път когато клиент го извика, ако има свободна каса, ще бъде обслужен клиентът на нея. В противен случай, изчакваме докато се освободи каса. 

(Предизвикателство: реализирайте метода без използване на допълнителна синхронизация)

### Задача 6

Няколкото на брой отворени каси подобряват значително потребителското изживяване на клиентите. С цел оптимизация на ресурсите си обаче, супермаркетите рядко държат отворени всички каси. За да можем да предвидим кога да отворим нова каса, когато се трупат нови клиенти в опашката, следете общото време, необходимо за обслужването им и при надвишаване на някакъв лимит `MAX_DELAY`, отворете нова каса. Броят на касите в супермаркета все пак е краен - не трябва да надвишава `MAX_DESKS`.
 
### Задача 7

Ако пък нямаме много клиенти, а в същото време имаме много отворени каси, не е рентабилно - плащаме излишни пари за заплати. След като дадена каса обслужи клиент и види, че общото време, необходимо за обслужването на чакащите в опашката клиенти е под някакъв минимум `MIN_DELAY`, касата се затваря. Броят на отворените касите не трябва да пада под 1. Когато затваряме каса, трябва да прехвърлим наличността ѝ към общата сметка в супермаркета. Обърнете внимание, че няколко каси могат да затворят едновременно.
