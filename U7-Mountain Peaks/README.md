# Lambda изрази и Stream API

## 1. Анализ на данни за планински върхове

В задачата ще имплементираме клас, който ще предоставя статистика върху dataset с най-високите планински върхове в света. Данните ще бъдат предоставени на вашата имплементация като файл ([mountains.txt](https://github.com/fmi/java-course/blob/master/07-files-and-lambdas/lab/resources/mountains.txt)), в който всеки ред съдържа данни за един връх в CSV (Comma-Separated Values) формат както следва:

`Позиция,Име,Височина,Изпъкналост,Планина,Година,Брой изкачвания`

Допълнителни разяснения към данните:

  - Позиция по височина - мястото по височина на съответния връх
  - Име (на върха)
  - Височина (в метри)
  - Изпъкналост (в метри) - показва височината на върха от най-високата седловина, свързваща го с по-висок връх) (виж [Topographic prominence](https://en.wikipedia.org/wiki/Topographic_prominence))
  - Планина – от коя планинска верига е част върхът
  - Година на първо изкачване
  - Брой изкачвания след 2004 г.

### Предизвикателство

Всеки един от методите, описани по-долу, може да бъде имплементиран в чист функционален стил - опитайте да решите условието без да ползвате statements / мутация на данни или странични ефекти (включително `Stream.forEach`).

### Обработка на данните

Класът `Peak` е immutable и ще представя данните за един връх. С цел удобна работа с lambda изрази, ще създаваме обекти от такъв тип чрез статичния factory method `createPeak`.

Създайте имплементация, която приема ред от dataset-a и връща инстанция на `Peak`. Може да разчитате, че данните са в коректен формат - типа им може да видите от предоставения source.

```java
public static Peak createPeak(String line);
```

След като имаме подходящ обект, можем да заредим данните в поток и (декларативно) да изведем разнообразни статистики. Класът, който ще ни предоставя API за статистиките, е `PeakStats`. За начало, имплементирайте конструктора му.

```java
// Изчита dataset-а и инициализира променливата peaks. Ще запазим
// върховете като List, за може да взимаме многократно Stream обект.
public PeakStats(String datasetPath)
```

### Статистики

`PeakStats` предоставя на ползвателите си полезни статистически данни чрез няколко метода. Създайте конкретна имплементация на всеки един от тях, която да отговаря на зададеното условие.

1. Определете височината на най-ниския връх, който никога не е бил изкачван

```java
public double shortestNotAscended();
```

2. Какъв е средният брой изкачвания на върховете в топ N (включително)? Да се върне 0.0, ако няма изкачен връх в интервала.

```java
public double avgAscentsTopN(int n);
```

3. Сред най-високите върхове има и такива, които имат относително малка изпъкналост - например четвъртият по височина връх Лхотце има скромните 610 м., за сравнение - първенецът на Балканите - Мусала - има цели 2473 м. Да се напише метод, който приема изпъкналост и връща като стойност на кое място би се наредил върхът по изпъкналост спрямо данните от нашия dataset. Ако има върх(ове) със същата изпъкналост, считаме, че върхът с подадената изпъкналост е по-висок от тях т.е. ще има по-предна позиция.

```java
public long getPositionByProminence(double prominence);
```

4. Най-високият връх, изкачен за пръв път през дадена година. Ако няма върхове, изкачени през тази година, да се хвърля `java.lang.IllegalArgumentException`.

```java
public Peak getHighestAscentPerYear(int year);
```

5. Имената на върховете, които не са част от Хималаите (която и да е планина, съдържащa `'Himalaya'` в името си), подредени по изпъкналост (от най-висок към най-нисък)

```java
List<String> getNonHimalayaNamesByProminence();
```

6. Коя планинска верига има най-много върхове в топ N (включително)? Да се изведе името ѝ. Ако няколко планински вериги имат равен резултат, няма значение коя от тях ще се върне.

```java
public String getRangeWithMostPeaks(int topN);
```

### Извеждане на данни в табличен вид

В допълнение на предоставените статистики, ползвателите на нашата имплементация искат да могат да си извеждат в табличен вид списък с върховете в даден интервал. Пример:

```
--------------------------------------------------    (1)
| Name                 |     Height | Prominence |    (2)
--------------------------------------------------    (1)
| Mount Everest        |    8848.00 |    8848.00 |    (3)
| K2                   |    8611.00 |    4017.00 |    (3)
| Kangchenjunga        |    8586.00 |    3922.00 |    (3)
| Lhotse               |    8516.00 |     610.00 |    (3)
--------------------------------------------------    (1)
```

Като програмисти знаем, че форматирането на низовете може да бъде tricky операция, а конкатенацията е много скъпа. Използването на mutable обект като `java.lang.StringBuilder` значително оптимизира бързодействието, но с цената на "грозен" код.

В тази част на задачата ще имплементираме функционалност, която извежда таблицата изцяло чрез Stream API.

За да опростим задачата, ще разгледаме таблицата като съвкупност от следните компоненти (цифрата в скоби е легенда спрямо таблицата по-горе):

  - tableHeader - състои се от dashRow(1), titleRow(2), dashRow(1).
  - tableBody - състои се от n bodyRows(3)
  - tableFooter - един dashRow(1)

Като първа стъпка, ще имплементираме няколко статични метода в класа `TableFormatter`. Класът съдържа няколко константи и два вече имплементирани метода

1. Предоставете имплементация на `dashGen()`. Методът трябва да връща безкраен поток от '-', за да може да си генерираме лесно и удобно редове, състоящи се от тирета.

```java
Stream<String> dashGen();
```

2. След това имплементирайте `dashRow()`, използвайки `dashGen()`. Лесно можем да си превърнем потока в краен и да сглобим елементите в единичен низ

```java
String dashRow();
```

3. За да върнем поток с три реда на tableHeader (dashRow + titleRow + dashRow), имплементирайте съответния метод. Функцията, която сглобява titleRow, ви е предоставена.

```java
Stream<String> tableHeader()
```

4. Последният статичен метод, който трябва да напишем в този клас, е `bodyRow`. Методът приема `Peak` обект и връща ред (низ, съдържащ име, височина и изпъкналост, разделени с '|')

Условия към форматирането:

  - името на върха да бъде максимум 20 символа, а ако е повече - да се "отреже", ляво подравнен
  - височина и изпъкналост са с 10 символа, 2 знака след десетичната запетая, дясно подравнени

```java
String bodyRow(Peak peak)
```

5. Следва забавната част - след като имаме всички редове на таблицата, сме готови да я сглобим. Връщаме се отново в `PeakStats`, където имаме:

```java
// Интервалът от върхове, който искаме да листнем. И двата индекса са inclusive
public String listPeaks(int from, int to);
```

Най-лесният начин да имплементираме функцията би бил да си вземем три Stream-a (header, body, footer), да ги обединим в един общ Stream и чрез reduce да върнем единичен низ.
